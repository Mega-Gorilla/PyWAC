# Migration Guide: v0.3.x to v0.4.0 (Queue-Based Architecture)

## Overview

Version 0.4.0 introduces a queue-based architecture that resolves GIL (Global Interpreter Lock) issues and dramatically improves CPU performance. This guide will help you migrate from previous versions.

## Breaking Changes

### 1. Module Names Changed
The process capture modules have been reorganized:
- `process_loopback_v2` → `process_loopback_queue` (recommended)
- `process_loopback_v3` → Deprecated (has GIL issues)

### 2. New Streaming Interface
The streaming capture now uses `QueueBasedStreamingCapture` instead of direct callbacks.

## Migration Steps

### Step 1: Update Imports

#### Old (v0.3.x)
```python
import process_loopback_v2 as loopback
from pywac.streaming import StreamingAudioCapture  # If it existed
```

#### New (v0.4.0)
```python
import process_loopback_queue as loopback
from pywac.queue_streaming import QueueBasedStreamingCapture
```

### Step 2: Update Process Capture Code

#### Old (Polling-based v0.3.x)
```python
import process_loopback_v2 as loopback

# List processes
processes = loopback.list_audio_processes()

# Create capture
capture = loopback.ProcessCapture()
capture.start(pid)

# Poll for data (inefficient)
while capturing:
    data = capture.get_buffer()  # Destructive read!
    if len(data) > 0:
        process_audio(data)
    time.sleep(0.01)  # Manual polling

capture.stop()
```

#### New (Queue-based v0.4.0)
```python
import process_loopback_queue as loopback

# List processes (same API)
processes = loopback.list_audio_processes()

# Create capture with queue
capture = loopback.QueueBasedProcessCapture(queue_size=1000)
capture.set_chunk_size(480)  # 10ms chunks at 48kHz
capture.start(pid)

# Efficient batch polling
while capturing:
    chunks = capture.pop_chunks(max_chunks=10, timeout_ms=10)
    for chunk in chunks:
        process_audio(chunk["data"])
        # Additional metadata available:
        # chunk["silent"] - bool
        # chunk["timestamp"] - microseconds

capture.stop()
```

### Step 3: Update Streaming Code

#### Old (Direct callback - had GIL issues)
```python
# This pattern caused GIL crashes
def callback(data):
    # Process audio
    pass

capture = SomeCallbackCapture()
capture.set_callback(callback)  # GIL issues!
capture.start()
```

#### New (Queue-based streaming)
```python
from pywac.queue_streaming import QueueBasedStreamingCapture
from pywac.audio_data import AudioData

def on_audio(audio: AudioData):
    # Safe callback - no GIL issues
    stats = audio.get_statistics()
    print(f"RMS: {stats['rms_db']:.1f} dB")

capture = QueueBasedStreamingCapture(
    process_id=pid,
    chunk_duration=0.01,  # 10ms chunks
    on_audio=on_audio,    # Optional callback
    batch_size=10         # Process 10 chunks at once
)

if capture.start():
    time.sleep(5)
    audio = capture.stop()  # Returns AudioData
    audio.save("output.wav")
```

### Step 4: Use Convenience Functions

For simple use cases, use the new convenience function:

```python
from pywac.queue_streaming import capture_process_audio

# Simple capture
audio = capture_process_audio(
    process_id=spotify_pid,
    duration=10.0,
    on_audio=lambda a: print(f"Chunk: {a.duration:.3f}s")
)
audio.save("spotify.wav")
```

## Performance Improvements

### CPU Usage
- **v0.3.x (Polling)**: 30-100% CPU
- **v0.4.0 (Queue)**: < 5% CPU

### Latency
- **v0.3.x**: Variable, often 50-100ms
- **v0.4.0**: Consistent ~10ms

### Data Integrity
- **v0.3.x**: Destructive reads, data loss possible
- **v0.4.0**: No data loss, zero dropped chunks

## Key Differences

### 1. Non-Destructive Reading
The queue-based approach doesn't destroy data when reading:
```python
# Old: get_buffer() cleared the buffer
data = capture.get_buffer()  # Data is gone!

# New: pop_chunks() is explicit
chunks = capture.pop_chunks()  # Clear intent
```

### 2. Batch Processing
Process multiple chunks efficiently:
```python
# Old: One at a time
data = capture.get_buffer()

# New: Batch processing
chunks = capture.pop_chunks(max_chunks=10)
for chunk in chunks:
    # Process batch
```

### 3. Adaptive Polling
The Python streaming layer now uses adaptive polling:
```python
capture = QueueBasedStreamingCapture(
    process_id=0,
    batch_size=10  # Automatically adjusts polling rate
)
# Polling interval: 1-20ms based on queue state
```

### 4. Metrics and Monitoring
New detailed metrics available:
```python
metrics = capture.get_metrics()
print(f"Total chunks: {metrics['total_chunks']}")
print(f"Dropped: {metrics['dropped_chunks']}")  # Should be 0
print(f"Queue size: {metrics['queue_size']}")
print(f"Efficiency: {metrics['efficiency']:.2f} chunks/poll")
```

## Troubleshooting

### Issue: Import Error
```python
ImportError: No module named 'process_loopback_queue'
```
**Solution**: Rebuild the extension:
```bash
python setup.py build_ext --inplace
```

### Issue: No Audio Captured
**Check**:
1. Target process is producing audio
2. Windows version >= 2004 (Build 19041)
3. Process ID is correct

### Issue: High CPU Usage
**Check**:
1. Using queue-based module (not v2 or v3)
2. Batch size is appropriate (10-20 chunks)
3. Not polling too frequently

## Example: Complete Migration

### Before (v0.3.x)
```python
import process_loopback_v2 as loopback
import numpy as np

capture = loopback.ProcessCapture()
capture.start(spotify_pid)

all_data = []
for _ in range(500):  # 5 seconds at 10ms intervals
    data = capture.get_buffer()
    if len(data) > 0:
        all_data.append(data)
    time.sleep(0.01)

capture.stop()
audio = np.concatenate(all_data)
# Save manually...
```

### After (v0.4.0)
```python
from pywac.queue_streaming import capture_process_audio

# Much simpler!
audio = capture_process_audio(spotify_pid, duration=5.0)
audio.save("spotify.wav")

# Or with streaming:
from pywac.queue_streaming import QueueBasedStreamingCapture

capture = QueueBasedStreamingCapture(
    process_id=spotify_pid,
    on_audio=lambda a: print(f"RMS: {a.get_statistics()['rms_db']:.1f} dB")
)

if capture.start():
    time.sleep(5)
    audio = capture.stop()
    audio.save("spotify.wav")
```

## Benefits Summary

1. **No GIL crashes** - Queue-based architecture avoids Python callback issues
2. **5x lower CPU usage** - Adaptive polling instead of constant polling
3. **Zero data loss** - Thread-safe queue with proper synchronization
4. **Better API** - AudioData objects, batch processing, metrics
5. **Production ready** - Tested with real applications (Spotify, Chrome, etc.)

## Need Help?

If you encounter issues during migration:
1. Check the test files for examples: `test_queue_capture.py`
2. Review the API reference: `docs/API_REFERENCE.md`
3. See implementation details: `docs/queue_implementation_summary.md`